/*__________________________________________________________________________________________

            (c) Hash(BEGIN(Satoshi[2010]), END(Sunny[2012])) == Videlicet[2014] ++

            (c) Copyright The Nexus Developers 2014 - 2019

            Distributed under the MIT software license, see the accompanying
            file COPYING or http://www.opensource.org/licenses/mit-license.php.

            "ad vocem populi" - To the Voice of the People

____________________________________________________________________________________________*/

#include "util.h"

#include <Util/include/random.h>

#include <unit/catch2/catch.hpp>

#include <LLD/include/global.h>

#include <TAO/API/crypto/types/crypto.h>
#include <TAO/API/include/global.h>

#include <Util/include/convert.h>
#include <Util/include/base64.h>

/* Public key name */
std::string KEY_NAME = "testkey";

/* Second key name used for testing the shared key */
std::string KEY_NAME_2 = "testkey2";

/* private key bytes */
std::string PRIVATE_KEY = "e80532ad5730b15df1d0b19988a89a9a46d843914554c38be914b1b09cbfc04156b50bcde3e11c31d7ffd22a823dbcde17625f563cc34de407229e3a6ab42f4f";

/* falcon public key bytes */
std::string PUBLIC_KEY_FALCON = "332iaASGQ4uUBZv9aGScXu5qEVQsrmx4kZvtUQdkNpMV7wqpABwdrUy5RxK1DqRpAtUmE3gSCNu86LCzKwG3GUyWc4TJ7hzp3xfSneSDC46gBAq6wqKh7jGbWRh4Mk2mdbH5utvv6VHtYixBLAcjypcCVqAqG2esHho1T3yk7BfKH6DDnK15Hs9DtvTeDfc14h63WkAzN1v2MhzKTZCJ3FCGRSGpMnc9RL8QP7RPjXdAD2iDitaHvC587SNdxSMrrG2smb75ZGrYDd8JDzk9V9ojyXSd3Fv7FwegLYoxH8hx7eLKTxoUEYZn9a39tzAxkm4sTc9bEXuDiGtEvbP2KfzT77oUeThcCpdH3zZ9q8HzvXNb37QLn162XnpkdGt7kGd6CTWd3qKzxifrvXsv6FdSZpVbMYv8VPE91Y9Ncw8T6Sxn58mqUDoxJpNjDB1fLFSk7kWiNLC6WEou3ugEGAoxs6zqxmTtDgVrhR5UsBfZ5mYEn5Zbhhgrpb5Durud7DLhRsHEru8N6oAdYhpBjwFUoqv2WfXLKEvQou6RfWNnzkkUppRHFXgX5Eq4YqkKMZVH4jVArUYay6RCmcK86jXbmSzbySgia9PZ6S1WZQCgVRwSqPGs3r1RZC4GMEqcenz5kTCba7Dit21AjKogoE5rdrmWpXWNzAUMkDKh2HMYaiFtrHS42qg4Gtr6uCupnWtvhjc1A1wTSE12tsVY6Dw1RqVJk4FE5t8KZD7k62cePfwVratDbNBCAWi8S2H4SbT1xmdXfJo9PTuBVrWvJbP6FmeG7Kbw5VtXhLJeyijZpS1TuntREz7d7FvhnDi9WJUGgQPe2G7gXwSZ1vD6yFGgpktG1cVohpnP9zZvvbr27RCtQ1XxqyvTf4RT8BBjc5JLGEaS68YozZKmEwMswQngJD7XApDZEdhXqe8hAAzkUQ9af5zWPG3NhbGdud8UZBNXvjCTaVryQcKmLFKmotzek7symo9JSDaQiXe3mM5WgcGw41twcdY8wD5eCiDBretX1tcGMu9oQEisXNJVXvZPNzJN6bWyxFiKu1EBtoe1MGjfgnfe3MzMWLFHPTXwPMFisbb3Pk5Hu2qtWTAaUoWqHWCqCbwehCuauPCfLLtLTSqMK8m9e9zPTUbNUoQZnXjKv8eaA5BSwfMG3ZZ7fywPrKgL5XpytxHsQ5osTxQp3TA5xXGCi3YdUQEGWnR8tXqhsKzA7";

/* brainpool public key bytes */
std::string PUBLIC_KEY_BRAINPOOL = "HkeUChW67HadfF2cEfYeZoRfo8bHhg9b6r6yKooVc93mRvQXydzTWdsqnMHE4rp5udQd9rqpZfrScfScQk3smzLW";

/* signature for the brainpool key generated by the API */
std::string SIGNATURE_BRAINPOOL = "";

/* signature for the brainpool key that we can check */
std::string SIGNATURE_BRAINPOOL_CHECK = "MIGEAkALjH/kSH6tCfpaw33fhxc/DHLTxJRFhd/S9ewhVRWTnyM2kQshufNaI0MCEp9riR1Ne0XhXiRbcJHBy8w3nATCAkB9lrnBg/ExHn4I/MS/zUwPAvBwU8BJYL3dxSqzBkNTdThRfM+nY4s61yGZQhO42UDEmzYuNOpluuuurZufv7h7";

/* signature for the falcon key generated by the API */
std::string SIGNATURE_FALCON = "";

/* signature for the falcon key */
std::string SIGNATURE_FALCON_CHECK = "WZazifZ5KAyNWSRFZqigC4jv6SmUsf6qCRots1x8PGO5koxd02lVS0X98IAV0dn5MHj47v0I0OoEoGkVQKUDH4z9/8/98F8DT4oCoAP7EDj9vxnq8DEAgCEN//IMoAsIIJgJ4Lf+8CYCANEHUM7xgNgCT4j8MJoC7/sLYRb3P2YSX0EG4PYDzzv7D7UPDtQRDzQG0KQQIRP7/47zD+8Fb7YAsaIFr6b0z4fz0IsDX8f/YO4Bj00BD+H9L8j3wDv9X7nyUK337vcMEA8Enq3//8MNXywG38T6z5UC4F79sDj7oTL2gGn1TngB38z6z9MMgAsCQH0A8SUGn77ujzn2D9P8nuwBXxn2b3blX4IUjpT2n6sHjwoV7/XukLv1cAQY4KT/r7XwkRcIP4D/XzwVf+cBn33z36gPD7b075cFIBUHL5D4Ptr4T/4Yr8/xTxHywZEaYMgDP0T28Lr/7xX7vp4GL+X9sTL7IHMDTrsG0G3zYSkGrur/EF0Eb/MKX74goJv08VALcLkFcCQAX/ECT80CwH32H68BneD9sCf2kCv87z/zEEEI75P0QFn4YAILzv3xAC0L8PbqUED+oSH4z1X4sNcA793uALf8YBINr34JcEv8sMYEgHb6QDUBLyTtLyQA8G7+363236z4v4wFsHv/3wTgH9H+MC8KIGD3D439oDMT39gM30T1T/YKYMENT+cCr8b+n7UCoJ8KIFL172gIIJz9/qYIrz3y/0XwwKTuoRb5vv4QXtb38Mj3f3b5T6L8r838gPMGYCf8L0IBb7z8f88PH/v7z273r8EDcOL30FsOECf2IG78QGMGL9YUoEsJHzf+gNT/z+/+0EbwQJr5IA0MPwf1sGn2H7Xzrzf+75X3vz3/gLkIj+X4AIf3z9sFUFcGUDjpTn8Fzr0CPyALf5/6oDL7f0IHsKICjjQBoDAEMFUCwIf2AL8Q76b+r9v68Ej/f7314YoOrxz3v8/7AS32sHL8IIIE3077IMYFQMQTgNr2MCgID5kbn9b4f+YAoEruXxv/0C36UK4H4HoGAGEA/+cAj5UG8K8DMIj2MGb7D577j5k=";

/* brainpool public key from key2 */
std::string PUBLIC_KEY_BRAINPOOL_2 = "K1FCufkNgAmxEhJoGHYFXZRWw2reUvXTGkLUySKBQUUP2qZVGSBGTVgkfPYdj8DtVVSEkFeezMNmS4yVLeYHGKdb";

/* 256-bit / 32-byte symmetric key used to test encryption */
std::string SYMMETRIC_KEY = "12345678123456781234567812345678";

/* plain text data to be encrypted */
std::string PLAIN_TEXT_DATA = "hello world"; 

/* result of the encryption using symmetric key */
std::string SYMMETRICKEY_CIPHERTEXT = "";

/* encrypted data using symmetric key to check decryption*/
std::string SYMMETRICKEY_CIPHERTEXT_CHECK = "rv5oJ+BdgruGEhs3BS6a8W9LMMDwmcpPtlvs7SvidJY=";


/* result of the encryption using private key */
std::string PRIVATEKEY_CIPHERTEXT = "";

/* encrypted data using private key to check decryption*/
std::string PRIVATEKEY_CIPHERTEXT_CHECK = "A4DfmcRpiXq/Bap2QSnzECbhm6dwxA03y0kRqeZLR9U=";


/* result of the encryption using shared symmetric key */
std::string SHAREDKEY_CIPHERTEXT = "";

/* encrypted data using shared symmetric key to check decryption*/
std::string SHAREDKEY_CIPHERTEXT_CHECK = "6QZlXzhNAKZxnrZf7rsGGlSnS+rjMbKmR0Tw65tq6Es=";

/* the public key from the shared key (the public key of testkey2) */
std::string SHARED_PUBLICKEY = "";

/* SK256 hash of plain text data (hello world) */
std::string HASH_SK256 = "79fe0c9f61d38652d1ec3165485196ca773b027750cc257494a1e16eb6aea5f1";

/* SK512 hash of plain text data (hello world) */
std::string HASH_SK512 = "d1a81402dadddf96d5b8d519bed5e779985fd256168db4534d0f1ca02cb031198b8a48979bdd4e6973157a61b684ba5ea25c9a020720c1aae242c6fcad0baf1a";

/* ARGON2 hash of plain text data (hello world) */
std::string HASH_ARGON2 = "9ad37226ee61778f3c7f3bed076475f6c81d7fd45de860af650b770d670c4e0e2e4b50844c9712260f69729c654ac685e668236e9ee3511bb920b868f4b7714c";


/* sig chain for testing crypto */
/* DO NOT CHANGE THESE CREDENTIALS AS THEY IMPACT ALL HARD-CODED TEST DATA ABOVE THAT IS USED TO VERIFY THE CRYPTO API METHODS */
std::string CRYPTO_USERNAME = "cryptouser";
std::string CRYPTO_PASSWORD = "cryptopassword";
std::string CRYPTO_PIN = "1234";
std::string CRYPTO_SESSION;
uint256_t CRYPTO_GENESIS = 0;

TEST_CASE( "Test Crypto API - list keys", "[crypto/list/keys]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);

    /* Successful get for logged in user*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/list/keys", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        /* Result must be an array */
        REQUIRE(result.is_array());

        /* Must be at least nine entries */
        REQUIRE(result.size() == 9);

        json::json key = result[0];

        REQUIRE(key.find("name") != key.end());
        REQUIRE(key.find("scheme") != key.end());
        REQUIRE(key.find("hashkey") != key.end());
    }
}


TEST_CASE( "Test Crypto API - create key", "[crypto/create/key]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);

    /* crypto/create/key fail with missing pin (only relevant for multiuser)*/
    if(config::fMultiuser.load())
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/create/key", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -129);
    }

    /* crypto/create/key fail with missing session (only relevant for multiuser)*/
    if(config::fMultiuser.load())
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;

        /* Invoke the API */
        ret = APICall("crypto/create/key", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -12);
    }

    /* crypto/create/key fail with missing name */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/create/key", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -88);
    }

    /* crypto/create/key fail with invalid key name */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;
        params["name"] = "notaname";

        /* Invoke the API */
        ret = APICall("crypto/create/key", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -260);
    }


    /* crypto/create/key fail with key already exists */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;
        params["name"] = "auth";

        /* Invoke the API */
        ret = APICall("crypto/create/key", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -261);
    }
    

    /* Successful create for logged in user*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;
        params["name"] = "app1";
        params["scheme"] = "brainpool";

        /* Invoke the API */
        ret = APICall("crypto/create/key", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("txid") != result.end());
        REQUIRE(result.find("name") != result.end());
        REQUIRE(result.find("hashkey") != result.end());
    }
}


TEST_CASE( "Test Crypto API - get key", "[crypto/get/key]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);

    /* Fail with invalid genesis */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["genesis"] = Util::GetRand256().ToString();

        /* Invoke the API */
        ret = APICall("crypto/get/key", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -258);
    }

    /* Fail with missing name */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["genesis"] = GENESIS1.ToString();

        /* Invoke the API */
        ret = APICall("crypto/get/key", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -88);
    }

    /* Fail with invalid key name */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["genesis"] = GENESIS1.ToString();
        params["name"] = "notakey";

        /* Invoke the API */
        ret = APICall("crypto/get/key", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -260);
    }

    /* Successful get for logged in user*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;
        params["name"] = "auth";

        /* Invoke the API */
        ret = APICall("crypto/get/key", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("name") != result.end());
        REQUIRE(result.find("scheme") != result.end());
        REQUIRE(result.find("hashkey") != result.end());
    }
}


TEST_CASE( "Test Crypto API - get public key", "[crypto/get/publickey]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);

    /* crypto/get/publickey fail with missing pin (only relevant for multiuser)*/
    if(config::fMultiuser.load())
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/get/publickey", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -129);
    }

    /* crypto/get/publickey fail with missing session (only relevant for multiuser)*/
    if(config::fMultiuser.load())
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;

        /* Invoke the API */
        ret = APICall("crypto/get/publickey", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -12);
    }


    /* Fail with missing name */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/get/publickey", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -88);
    }

    /* Fail with invalid scheme */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;
        params["name"] = KEY_NAME;
        params["scheme"] = "notascheme";

        /* Invoke the API */
        ret = APICall("crypto/get/publickey", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -262);
    }

    /* Successful get based on brainpool scheme*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME;
        params["scheme"] = "brainpool";

        /* Invoke the API */
        ret = APICall("crypto/get/publickey", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("publickey") != result.end());
        REQUIRE(result.find("scheme") != result.end());

        /* Check value of the public key is what we expect for this sig chain*/
        std::string strKey = result["publickey"].get<std::string>();
        REQUIRE(strKey == PUBLIC_KEY_BRAINPOOL);

    }

    /* Successful get based on falcon scheme*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME;
        params["scheme"] = "falcon";

        /* Invoke the API */
        ret = APICall("crypto/get/publickey", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("publickey") != result.end());
        REQUIRE(result.find("scheme") != result.end());

        /* Check value of the public key is what we expect for this sig chain*/
        std::string strKey = result["publickey"].get<std::string>();
        REQUIRE(strKey == PUBLIC_KEY_FALCON);

    }
}


TEST_CASE( "Test Crypto API - get private key", "[crypto/get/private]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);

    /* crypto/get/private fail with missing pin (only relevant for multiuser)*/
    if(config::fMultiuser.load())
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/get/privatekey", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -129);
    }

    /* crypto/get/private fail with missing session (only relevant for multiuser)*/
    if(config::fMultiuser.load())
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;

        /* Invoke the API */
        ret = APICall("crypto/get/privatekey", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -12);
    }


    /* Fail with missing name */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/get/privatekey", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -88);
    }

    /* Successful get */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME;

        /* Invoke the API */
        ret = APICall("crypto/get/privatekey", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("privatekey") != result.end());

        /* Check value of the public key is what we expect for this sig chain*/
        std::string strKey = result["privatekey"].get<std::string>();
        REQUIRE(strKey == PRIVATE_KEY);

    }   
}


TEST_CASE( "Test Crypto API - change scheme", "[crypto/change/scheme]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);

    /* crypto/get/private fail with missing pin (only relevant for multiuser)*/
    if(config::fMultiuser.load())
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/change/scheme", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -129);
    }

    /* crypto/get/private fail with missing session (only relevant for multiuser)*/
    if(config::fMultiuser.load())
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;

        /* Invoke the API */
        ret = APICall("crypto/change/scheme", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -12);
    }


    /* Fail with missing scheme */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/change/scheme", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -275);
    }

    /* Fail with invalid scheme */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;
        params["scheme"] = "notascheme";

        /* Invoke the API */
        ret = APICall("crypto/change/scheme", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -262);
    }

    /* Successful change to falcon (default is brainpool)*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["scheme"] = "FALCON";

        /* Invoke the API */
        ret = APICall("crypto/change/scheme", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("txid") != result.end());

    } 

    /* Fail with scheme already in use*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["scheme"] = "FALCON";

        /* Invoke the API */
        ret = APICall("crypto/change/scheme", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -278);

    }  

    /* Successful change back to brainpool*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["scheme"] = "BRAINPOOL";

        /* Invoke the API */
        ret = APICall("crypto/change/scheme", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("txid") != result.end());

    }  
}


TEST_CASE( "Test Crypto API - encrypt data", "[crypto/encrypt/data]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);


    /* Fail with missing data */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/encrypt/data", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -18);
    }


    /* Fail with malformed key */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = CRYPTO_PIN;
        params["key"] = "**not_a#key**";

        /* Invoke the API */
        ret = APICall("crypto/encrypt/data", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -270);
    }

    
    /* Successful encrypt using symmetric key*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PLAIN_TEXT_DATA;
        params["key"] = SYMMETRIC_KEY;

        /* Invoke the API */
        ret = APICall("crypto/encrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());

        debug::log(0, "SYMMETRICKEY_CIPHERTEXT ", result["data"].get<std::string>());

        /* extract the encrypted data in order to check the decryption of it later */
        SYMMETRICKEY_CIPHERTEXT = result["data"].get<std::string>();
    } 


    /* Successful encrypt using private key*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PLAIN_TEXT_DATA;
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME;

        /* Invoke the API */
        ret = APICall("crypto/encrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());
        REQUIRE(result.find("publickey") != result.end());

        debug::log(0, "PRIVATEKEY_CIPHERTEXT ", result["data"].get<std::string>());

        /* extract the encrypted data in order to check the decryption of it later */
        PRIVATEKEY_CIPHERTEXT = result["data"].get<std::string>();

    } 


    /* Successful encrypt using shared key*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PLAIN_TEXT_DATA;
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME;
        params["peerkey"] = PUBLIC_KEY_BRAINPOOL_2;

        /* Invoke the API */
        ret = APICall("crypto/encrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());
        REQUIRE(result.find("publickey") != result.end());

        /* extract the encrypted data in order to check the decryption of it later */
        SHAREDKEY_CIPHERTEXT = result["data"].get<std::string>();
        SHARED_PUBLICKEY = result["publickey"].get<std::string>();

        debug::log(0, "SHAREDKEY_CIPHERTEXT ", result["data"].get<std::string>());

        /* Check that the correct public key has been returned for the private key */
        REQUIRE(SHARED_PUBLICKEY == PUBLIC_KEY_BRAINPOOL);

    } 

      
}


TEST_CASE( "Test Crypto API - decrypt data", "[crypto/decrypt/data]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);


    /* Fail with missing data */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -18);
    }


    /* Fail with invalid symmetric key */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = SYMMETRICKEY_CIPHERTEXT_CHECK;
        params["key"] = "notakey";

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -271);
    }

    /* Fail with invalid key when private key is used for symmetric key */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PRIVATEKEY_CIPHERTEXT_CHECK;
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["scheme"] = "brainpool";
        params["name"] = "notakey"; 

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -271);
    }

    /* Fail with invalid key when incorrect private key is provided for shared key*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PRIVATEKEY_CIPHERTEXT_CHECK;
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = "notakey";
        params["peerkey"] = PUBLIC_KEY_BRAINPOOL_2; 

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -271);
    }

    /* Successful decrypt of hard coded check data using symmetric key*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = SYMMETRICKEY_CIPHERTEXT_CHECK;
        params["key"] = SYMMETRIC_KEY;

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());

        /* extract the decrypted data and check it */
        std::string strDecrypted = result["data"].get<std::string>();

        REQUIRE(strDecrypted == PLAIN_TEXT_DATA);
    } 

    /* Successful decrypt of data previously encrypted via API using symmetric key*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = SYMMETRICKEY_CIPHERTEXT;
        params["key"] = SYMMETRIC_KEY;

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());

        /* extract the decrypted data and check it */
        std::string strDecrypted = result["data"].get<std::string>();

        REQUIRE(strDecrypted == PLAIN_TEXT_DATA);
    }


    /* Successful decrypt of hard coded check data using private key*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PRIVATEKEY_CIPHERTEXT_CHECK;
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME;

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());

        /* extract the decrypted data and check it */
        std::string strDecrypted = result["data"].get<std::string>();

        REQUIRE(strDecrypted == PLAIN_TEXT_DATA);
    } 

    /* Successful decrypt of data previously encrypted via API using private key*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PRIVATEKEY_CIPHERTEXT;
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME;

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());

        /* extract the decrypted data and check it */
        std::string strDecrypted = result["data"].get<std::string>();

        REQUIRE(strDecrypted == PLAIN_TEXT_DATA);
    }


    /* Successful decrypt of hard coded check data using shared key, using private key of first user*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = SHAREDKEY_CIPHERTEXT_CHECK;
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME;
        params["peerkey"] = PUBLIC_KEY_BRAINPOOL_2;

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());

        /* extract the decrypted data and check it */
        std::string strDecrypted = result["data"].get<std::string>();

        REQUIRE(strDecrypted == PLAIN_TEXT_DATA);
    }

    /* Successful decrypt of data previously encrypted via API using shared key, using private key of first user*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = SHAREDKEY_CIPHERTEXT;
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME;
        params["peerkey"] = PUBLIC_KEY_BRAINPOOL_2;

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());

        /* extract the decrypted data and check it */
        std::string strDecrypted = result["data"].get<std::string>();

        REQUIRE(strDecrypted == PLAIN_TEXT_DATA);
    }


    /* Successful decrypt of hard coded check data using shared key, using private key of second user*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = SHAREDKEY_CIPHERTEXT_CHECK;
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME_2;
        params["peerkey"] = PUBLIC_KEY_BRAINPOOL;

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());

        /* extract the decrypted data and check it */
        std::string strDecrypted = result["data"].get<std::string>();

        REQUIRE(strDecrypted == PLAIN_TEXT_DATA);
    }

    /* Successful decrypt of data previously encrypted via API using shared key, using private key of second user*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = SHAREDKEY_CIPHERTEXT;
        params["session"] = CRYPTO_SESSION;
        params["pin"] = CRYPTO_PIN;
        params["name"] = KEY_NAME_2;
        params["peerkey"] = PUBLIC_KEY_BRAINPOOL;

        /* Invoke the API */
        ret = APICall("crypto/decrypt/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("data") != result.end());

        /* extract the decrypted data and check it */
        std::string strDecrypted = result["data"].get<std::string>();

        REQUIRE(strDecrypted == PLAIN_TEXT_DATA);
    }

}


TEST_CASE( "Test Crypto API - sign data", "[crypto/sign/data]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);

    /* crypto/get/private fail with missing pin (only relevant for multiuser)*/
    if(config::fMultiuser.load())
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/sign/data", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -129);
    }

    /* crypto/get/private fail with missing session (only relevant for multiuser)*/
    if(config::fMultiuser.load())
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;

        /* Invoke the API */
        ret = APICall("crypto/sign/data", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -12);
    }


    /* Fail with missing name */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;

        /* Invoke the API */
        ret = APICall("crypto/sign/data", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -88);
    }

    /* Fail with missing data */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;
        params["name"] = KEY_NAME;

        /* Invoke the API */
        ret = APICall("crypto/sign/data", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -18);
    }


    
    /* Successful sign using brainpool key*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;
        params["scheme"] = "BRAINPOOL";
        params["name"] = KEY_NAME;
        params["data"] = PLAIN_TEXT_DATA;


        /* Invoke the API */
        ret = APICall("crypto/sign/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("publickey") != result.end());
        REQUIRE(result.find("scheme") != result.end());
        REQUIRE(result.find("signature") != result.end());

        debug::log(0, "SIGNATURE_BRAINPOOL ", result["signature"].get<std::string>());

        /* extract the signature data so we can verify it */
        SIGNATURE_BRAINPOOL = result["signature"].get<std::string>();
    } 


    /* Successful sign using falcon key*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["pin"] = CRYPTO_PIN;
        params["session"] = CRYPTO_SESSION;
        params["scheme"] = "FALCON";
        params["name"] = KEY_NAME;
        params["data"] = PLAIN_TEXT_DATA;


        /* Invoke the API */
        ret = APICall("crypto/sign/data", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("publickey") != result.end());
        REQUIRE(result.find("scheme") != result.end());
        REQUIRE(result.find("signature") != result.end());

        debug::log(0, "SIGNATURE_FALCON ", result["signature"].get<std::string>());

        /* extract the signature data so we can verify it */
        SIGNATURE_FALCON = result["signature"].get<std::string>();

    }
}


TEST_CASE( "Test Crypto API - verify signature", "[crypto/verify/signature]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);


    /* Fail with missing publickey */
    {
        /* Build the parameters to pass to the API */
        params.clear();

        /* Invoke the API */
        ret = APICall("crypto/verify/signature", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -265);
    }

    /* Fail with missing scheme */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["publickey"] = PUBLIC_KEY_BRAINPOOL;
        
        /* Invoke the API */
        ret = APICall("crypto/verify/signature", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -275);
    }

    /* Fail with missing signature */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["publickey"] = PUBLIC_KEY_BRAINPOOL;
        params["scheme"] = "BRAINPOOL";
        
        /* Invoke the API */
        ret = APICall("crypto/verify/signature", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -274);
    }

    /* Fail with missing data */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["publickey"] = PUBLIC_KEY_BRAINPOOL;
        params["scheme"] = "BRAINPOOL";
        params["signature"] = SIGNATURE_BRAINPOOL_CHECK;
        
        /* Invoke the API */
        ret = APICall("crypto/verify/signature", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -18);
    }

    /* fail with invalid signature */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["publickey"] = PUBLIC_KEY_BRAINPOOL;
        params["scheme"] = "BRAINPOOL";
        params["signature"] = "NOT A SIGNATURE";
        params["data"] = PLAIN_TEXT_DATA;


        /* Invoke the API */
        ret = APICall("crypto/verify/signature", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("verified") != result.end());

        /* check the result */
        REQUIRE(result["verified"].get<bool>() == false);
    }

    /* Successful verify using brainpool key and static signature*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["publickey"] = PUBLIC_KEY_BRAINPOOL;
        params["scheme"] = "BRAINPOOL";
        params["signature"] = SIGNATURE_BRAINPOOL_CHECK;
        params["data"] = PLAIN_TEXT_DATA;

        /* Invoke the API */
        ret = APICall("crypto/verify/signature", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("verified") != result.end());

        /* check the result */
        REQUIRE(result["verified"].get<bool>() == true);
    }


    /* Successful verify using falcon key and static signature*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["publickey"] = PUBLIC_KEY_FALCON;
        params["scheme"] = "FALCON";
        params["signature"] = SIGNATURE_FALCON_CHECK;
        params["data"] = PLAIN_TEXT_DATA;

        /* Invoke the API */
        ret = APICall("crypto/verify/signature", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("verified") != result.end());

        /* check the result */
        REQUIRE(result["verified"].get<bool>() == true);
    } 

    
    /* Successful verify using brainpool key and signature captured from crypto/sign/data*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["publickey"] = PUBLIC_KEY_BRAINPOOL;
        params["scheme"] = "BRAINPOOL";
        params["signature"] = SIGNATURE_BRAINPOOL;
        params["data"] = PLAIN_TEXT_DATA;

        /* Invoke the API */
        ret = APICall("crypto/verify/signature", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("verified") != result.end());

        /* check the result */
        REQUIRE(result["verified"].get<bool>() == true);
    }


    /* Successful verify using falcon key and signature captured from crypto/sign/data*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["publickey"] = PUBLIC_KEY_FALCON;
        params["scheme"] = "FALCON";
        params["signature"] = SIGNATURE_FALCON;
        params["data"] = PLAIN_TEXT_DATA;

        /* Invoke the API */
        ret = APICall("crypto/verify/signature", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("verified") != result.end());

        /* check the result */
        REQUIRE(result["verified"].get<bool>() == true);
    } 

}

TEST_CASE( "Test Crypto API - get hash", "[crypto/get/hash]")
{
    /* Declare variables shared across test cases */
    json::json params;
    json::json ret;
    json::json result;
    json::json error;

    /* Ensure user is created and logged in for testing */
    InitializeUser(CRYPTO_USERNAME, CRYPTO_PASSWORD, CRYPTO_PIN, CRYPTO_GENESIS, CRYPTO_SESSION);

    /* Fail with missing data */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        /* Invoke the API */
        ret = APICall("crypto/get/hash", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -18);
    }

    /* fail with invalid function */
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PLAIN_TEXT_DATA;
        params["function"] = "NOT A FUNCTION";

        /* Invoke the API */
        ret = APICall("crypto/get/hash", params);

        /* Check response is an error and validate error code */
        REQUIRE(ret.find("error") != ret.end());
        REQUIRE(ret["error"]["code"].get<int32_t>() == -277);
    }

    /* Successful hash using SK256*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PLAIN_TEXT_DATA;
        params["function"] = "SK256";

        /* Invoke the API */
        ret = APICall("crypto/get/hash", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("hash") != result.end());

        debug::log(0, "HASH_SK256 ", result["hash"].get<std::string>());

        /* check the result */
        REQUIRE(result["hash"].get<std::string>() == HASH_SK256);
    }

    /* Successful hash using SK512*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PLAIN_TEXT_DATA;
        params["function"] = "SK512";

        /* Invoke the API */
        ret = APICall("crypto/get/hash", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("hash") != result.end());

        debug::log(0, "HASH_SK512 ", result["hash"].get<std::string>());

        /* check the result */
        REQUIRE(result["hash"].get<std::string>() == HASH_SK512);
    }

    /* Successful hash using ARGON2*/
    {
        /* Build the parameters to pass to the API */
        params.clear();
        params["data"] = PLAIN_TEXT_DATA;
        params["function"] = "ARGON2";

        /* Invoke the API */
        ret = APICall("crypto/get/hash", params);

        /* Check that the result is as we expect it to be */
        REQUIRE(ret.find("result") != ret.end());
        result = ret["result"];

        REQUIRE(result.find("hash") != result.end());

        debug::log(0, "HASH_ARGON2 ", result["hash"].get<std::string>());

        /* check the result */
        REQUIRE(result["hash"].get<std::string>() == HASH_ARGON2);
    }

}


